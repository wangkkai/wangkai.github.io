---
title: 蓄水池算法
date: 2017-8-15 19:22:55
tags: [概率]
categories: 算法
---
>有一个机器按自然数序列的方式吐出球（1号球，2号球，3号球，……），你有一个袋子，袋子最多只能装下K个球，并且除袋子以外，你没有更多的空间。设计一种选择方式，使得当机器吐出第N号球的时候（N>K），你袋子中的球数是K个，同时可以保证从1号球到N号球中的每一个，被选进袋子的概率都是K/N。举一个更具体的例子，有一个只能装下10个球的袋子，当吐出100个球时，袋子里有10个球，并且1~100号中的每一个球被选中的概率都是10/100。然后继续吐球，当吐出1000个球时，袋子里有10个球，并且1~1000号中的每一个球被选中的概率都是10/1000。继续吐球，当吐出i个球时，袋子里有10个球，并且1~i号中的每一个球被选中的概率都是10/i，即吐球的同时，已经吐出的球被选中的概率也动态地变化。  

如果对上面的题目感觉有点困惑，那就举个现实中的例子。比如公司举行抽奖活动，奖品有100个。使得每个人抽中的概率都是相等的。比如有N个人，那么每个人的概率应该是100/N. 但是为了节省空间，我们不一定非要等N个人到齐了才进行抽奖。我们的目的是任何时刻的抽奖的概率都是相等的。  
好，继续原题。  
思路如下：    
假设袋子容量是10。那么对于前10个球，我们直接放入袋子。当第11个求你到来的时候，我们怎么处理呢？  
我们将第11号球放入袋子的概率是10/11。为什么这么做是对的呢？  
首先，对于第11球来说，它进入的概率是10/11。这个就不用证明了，一定是对的。那么对于袋子里的球怎么处理呢？  
我们以1/10的概率从袋子里取出一个球扔掉。那么该球的概率满足10/11吗？  
当然是满足的。因为它要是被扔掉，那么前提是第11号球进来，概率是10/11再乘以它被扔掉的概率1/10,所以总的被扔的概率是1/11.那么留下来的概率是10/11.  

至于代码的实现，就比较容易了。  
10/11这种概率的问题可以转化为Rand()函数产生0~11.如果小于11就放进去这种操作。
```
public class ReservoirSampling {

    // 一个简单的随机函数，决定一个事情做还是不做
    public static int rand(int max) {
        // 等概率返回1~max中的一个   -> 0~max-1 +1 -> 1~max
        return (int) (Math.random() * max) + 1;
    }

    public static int[] getKNumsRand(int k, int max) {
        if (max < 1 || k < 1) {
            return null;
        }
        int[] res = new int[Math.min(k, max)];
        for (int i = 0; i != res.length; i++) {
            res[i] = i + 1; // 前k个数直接进袋子
        }
        for (int i = k + 1; i < max + 1; i++) {
            if (rand(i) <= k) { // 决定i进不进袋子
                res[rand(k) - 1] = i; // i随机替掉袋子中的一个
            }
        }
        return res;
    }

    public static void printArray(int[] arr) {
        for (int i = 0; i != arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] res = getKNumsRand(10, 10000);
        printArray(res);
    }

}
```