---
title: 过桥问题
date: 2017-8-21 16:29:05
tags: [动态规划]
categories: 算法
---
>在一个夜黑风高的晚上，有n（n <= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。

对于这个问题，大家的第一想法就是每次都让最快的往返。那么实际的时间就是固定的一个值了。结果等于除了最快的以外，其他的累加和+最快的返回的次数。但是，实际的结果并不是这样的额，也就是上面的计算方法并不一定是最优的。  
【例子】  
四个人过桥花费的时间分别为 1 2 5 10。
那么按照上面的计算，结果为19，但是17就可以。  

* 首先1和2先过去，然后1返回，花费2+1=3.
* 接着5和10过去，然后2返回，花费10+2=12.
* 最后1和2过去，花费2.  
所以总的时间为3+12+2=17.

那么这种问题是怎么计算的呢？  
我们先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]，那么考虑前i-1个人过河的情况，即河这边还有1个人，河那边有i-1个人，并且这时候手电筒肯定在对岸，所以opt[i] = opt[i-1] + a[1] + a[i]        (让花费时间最少的人把手电筒送过来，然后和第i个人一起过河)
如果河这边还有两个人，一个是第i号，另外一个无所谓，河那边有i-2个人，并且手电筒肯定在对岸，所以opt[i] = opt[i-2] + a[1] + a[i] + 2*a[2]    (让花费时间最少的人把电筒送过来，然后第i个人和另外一个人一起过河，由于花费时间最少的人在这边，所以下一次送手电筒过来的一定是花费次少的，送过来后花费最少的和花费次少的一起过河，解决问题)
所以 opt[i] = min{opt[i-1] + a[1] + a[i] , opt[i-2] + a[1] + a[i] + 2*a[2] }

```
public class MinTime {
    public static void main(String[] args) {
        int a[] = {1, 2, 5, 10};
        System.out.println(time(a));
    }

    public static int time(int a[]) {
        if (a.length == 1) {
            return a[0];
        }
        if (a.length == 2) {
            return Math.max(a[0], a[1]);
        }

        int dp[] = new int[a.length];
        dp[0] = a[0];
        dp[1] = Math.max(a[0], a[1]);
        Arrays.sort(a);
        for (int i = 2; i < a.length; i++) {
            dp[i] = Math.min(a[i] + dp[i - 1] + a[0], dp[i - 2] + 2 * a[1] + a[0] + a[i]);
        }
        return dp[dp.length - 1];
    }

}
```